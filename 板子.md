# 算法竞赛模板

金泽楷  河海大学

## 基础

### tuple

```c++
tuple<int,int,string> a;
a=make_tuple(1,2,"abc");
int w=get<0>(a);
get<0>(a)=100;
```

### priority_queue

```c++
priority_queue<int,vector<int>,greater<int>> min_pq;
min_pq.push(3);
int val=min_pq.top();
min_pq.pop();

auto cmp=[&](const int& a,const int& b) {
    return a>b;//小顶堆
};
priority_queue<int,vector<int>,decltype(cmp)> pq(cmp);//小的在前
set<int,decltype(cmp)> st(cmp);//大的在前
```

### 位运算

```c++
popcount()//1的个数
countl_zero()//前导零
countr_zero()//后缀零
countl_one()//前导1
countr_one()//后缀1
has_single_bit()//是否只有一个1
bit_floor()	//向下取整到最近的2的幂
bit_ceil()	//向上取整到最近的2的幂
    
__builtin_popcount();//1的个数
__builtin_popcountll();
__builtin_clz();//前导零
__builtin_clzll();//ull
__builtin_ctz()//后缀零
__builtin_ctzll();//ull
```

### 向上向下取整

```c++
int Ceil(int n1,int n2) {
    if (n2 == 0) return 0;
    int x=n1/n2;
    int r=n1%n2;
    if (r != 0 and !((n1 < 0)^(n2 < 0))) x++;
    return x;
}

int Floor(int n1,int n2) {
    if (n2 == 0) return 0;
    int x=n1/n2;
    int r=n1%n2;
    if (r != 0 and ((n1 < 0)^(n2 < 0))) x--;
    return x;
}
```

### RandINT

```c++
int randINT(int l, int r) {
    static mt19937 gen(chrono::steady_clock::now().time_since_epoch().count());
    uniform_int_distribution<> distrib(l, r);
    return distrib(gen);
}
```

### 三分(二次函数)

```c++
int a,b,c;
int f(int x) {
	return a*x*x+b*x+c;
}


int ts(int L,int R){
    if (L > R) return 0;
    while (R-L > 3) {
        int mid1=L+(R-L)/3;
        int mid2=R-(R-L)/3;
        if (f(mid1) < f(mid2)) {
            L=mid1+1;
        }
        else {
            R=mid2-1;
        }
    }
    int ans = 0;
    for (int i=L;i<=R;i++){
        ans=max(ans,f(i));
    }
    return ans;
}
```

### 手写哈希

```c++
struct custom_hash {
	static uint64_t splitmix64(uint64_t x) {
		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};
unordered_map<int, int, custom_hash> safe_map;
```

### 异或哈希

```c++
//题意是找到同区块前提下的最长段
//暴力,n较小时
mt19937_64 rng {chrono::steady_clock::now().time_since_epoch().count()};
void solve()
{
	int n,m;
	cin>>n>>m;
	vector<u64> f(n);
	for(int i=0;i<m;i++) {
		int n1,n2;
		cin>>n1>>n2;
		n1--,n2--;
		u64 x=rng();
		f[n1]^=x;
		f[n2]^=x;
	}
	for(int i=1;i<n;i++) f[i]^=f[i-1];
	
	map<u64,int> cnt;
	for(int i=0;i<n;i++) cnt[f[i]]++;//同区块的线段长度
	
	int ans=0;
	for(auto [e1,e2] : cnt) ans=max(ans,e2);
		
	cout<<n-ans<<"\n";
}

//n较大时
	int n,m;
	cin>>n>>m;
	map<int,u64> f;
	f[n]=0;
	for(int i=0;i<m;i++) {
		int n1,n2;
		cin>>n1>>n2;
		u64 x=rng();
		f[n1]^=x;
		f[n2]^=x;
	}
	
	map<u64,int> cnt;
	int p=-1;
	u64 val=0;
	for(auto& [id,x] : f) {
		cnt[val]+=id-p-1;
		val^=x;
		p=id;
	}
```



## 图论

### LCA

```c++
vector<vector<int>> fa;
vector<int> depth;
void build(const vector<vector<int>>& adj, int root) {
	int n=adj.size();
    int m = log2(n) + 1;
    fa.assign(m + 1, vector<int>(n, -1));
    depth.assign(n, -1);
    
    queue<int> q;
    q.push(root);
    depth[root] = 0;
    fa[0][root] = -1;
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        
        for (int v : adj[u]) {
            if (depth[v] == -1) {
                depth[v] = depth[u] + 1;
                fa[0][v] = u;
                q.push(v);
            }
        }
    }
    
    for (int k = 1; k <= m; k++) {
        for (int u = 0; u < n; u++) {
            if (fa[k-1][u] != -1) {
                fa[k][u] = fa[k-1][fa[k-1][u]];
            } else {
                fa[k][u] = -1;
            }
        }
    }
}

int lift(int u, int target) {
    int diff = depth[u] - target;
    int k = 0;
    
    while (diff > 0) {
        if (diff & 1) {
            u = fa[k][u];
        }
        diff >>= 1;
        k++;
    }
    return u;
}

int query(int u, int v) {
    if (depth[u] < depth[v]) swap(u, v);
    u = lift(u, depth[v]);
    if (u == v) return u;
    
    int m = fa.size() - 1;
    for (int k = m; k >= 0; k--) {
        if (fa[k][u] != fa[k][v]) {
            u = fa[k][u];
            v = fa[k][v];
        }
    }
    
    return fa[0][u];
}
```

### 树的直径

```c++
auto bfs=[&](int s) {
    vector<int> dis(n,-1);
    queue<int> q;
    q.push(s);
    dis[s] = 0;

    while (!q.empty()) {
        int u = q.front();
        q.pop();

        for (auto v : adj[u]) {
            if (dis[v] == -1) {
                dis[v]=dis[u]+1;
                q.push(v);
            }
        }
    }
    return ranges::max_element(dis)-dis.begin();
};

int s = bfs(0);
int t = bfs(s);
```

### 树的重心

```c++
vector<int> Centroid(const vector<vector<int>>& adj) {
    int n=adj.size();
    vector<int> res;
    vector<int> siz(n,0);
    int maxn=n+1;

    function<void(int, int)> dfs = [&](int u, int fa) {
        siz[u]=1;
        int x=0; 

        for (int v : adj[u]) {
        	if (v == fa) continue;
            dfs(v,u);
            siz[u]+=siz[v];
            x=max(x,siz[v]);
        }

        x=max(x,n-siz[u]);

        if (x < maxn) {
            maxn=x;
            res.clear();
            res.push_back(u);
        } 
        else if (x == maxn) {
            res.push_back(u);
        }
    };
    
    dfs(0,-1);
    return res;
}
```

### 树上倍增

```c++
class TreeAnc {
private:
    vector<vector<int>> anc;
    int maxLog;
    vector<int> depth;

public:
    TreeAnc(vector<vector<int>>& adj, int root = 1) {
        int n = adj.size();
        maxLog = __lg(n)+1;
        anc.resize(maxLog, vector<int>(n, -1));
        
        //bfs
        depth.assign(n,-1);
        vector<int> st;
        st.push_back(root);
        depth[root] = 0;
        while (!st.empty()) {
            int node = st.back();
            st.pop_back();
            for (int son : adj[node]) {
                if (depth[son] == -1) {
                    depth[son] = depth[node] + 1;
                    anc[0][son] = node;
                    st.push_back(son);
                }
            }
        }

        for (int i = 1; i < maxLog; i++) {
            for (int j = 0; j < n; j++) {
                if (anc[i-1][j] != -1) {
                    anc[i][j] = anc[i-1][anc[i-1][j]];
                }
            }
        }
    }

    int query(int p, int step) {
        if (step < 0) return -1;
        for (int i = 0; i < maxLog; i++) {
            if (step & (1ll << i)) {
                p = anc[i][p];
                if (p == -1) break;
            }
        }
        return p;
    }
    
    //0-based
    int deep(int p) {
    	return depth[p];
    }
};
```

### Dijkstra

```c++
const int inf=1e18;
vector<int> dijkstra(vector<vector<array<int,2>>> &adj, int start) {
    int n = adj.size();
    vector<int> dis(n, inf);
    dis[start] = 0;
    set<array<int,2>> st;
    st.insert({0, start});
    while (!st.empty()) {
        auto [cdis, u] = *st.begin();
        st.erase(st.begin());
        if (cdis > dis[u]) continue;
        for (auto &[v, w] : adj[u]) {
            int ndis = dis[u] + w;
            if (ndis < dis[v]) {
                dis[v] = ndis;
                st.insert({ndis, v});
            }
        }
    }
    return dis;
}
```

### 拓扑排序

```c++
//对DAG拓扑排序
vector<int> topo(vector<vector<int>>& adj) {
	int n=adj.size();
	vector<int> deg(n);
	for(int u=0;u<n;u++) {
		for(auto v : adj[u]) deg[v]++;
	}
	
	queue<int> q;
	for(int i=0;i<n;i++) {
		if (deg[i] == 0) q.push(i);
	}
	
	vector<int> order;
	while (!q.empty()) {
		int u=q.front();
		q.pop();
		order.push_back(u);
		
		for(auto v : adj[u]) {
			deg[v]--;
			if (deg[v] == 0) q.push(v);
		}
	}
	
	return order;
}
```

### DAG_DP求点权max

```c++
//从s到某点路径上的最大点权和
const int inf=1e18;
vector<int> DAG_DP(vector<vector<int>> adj,vector<int> w,int s) {
	int n=adj.size();
	vector<int> deg(n,0);
	for(int u=0;u<n;u++) {
		for(int v : adj[u]) deg[v]++;
	}
	
	queue<int> q;
	for(int i=0;i<n;i++) {
		if (deg[i] == 0) q.push(i);
	}
	
	vector<int> dp(n,-inf);
	dp[s]=w[s];
	
	while (!q.empty()) {
		int u=q.front();
		q.pop();
		
		for(int v : adj[u]) {
			if (dp[u] != -inf) dp[v]=max(dp[v],dp[u]+w[v]);
			deg[v]--;
			if (deg[v] == 0) q.push(v);
		}
	}
	
	return dp;
}
```

### DAG上的最长链

```c++
int MaxPath(vector<vector<int>>& adj) {
	unordered_map<int,int> dp;
	function<int(int)> dfs=[&](int u) {
	    if (dp.count(u)) return dp[u];
	    int max_len=0;
	    for (int v : adj[u]) {
	        max_len=max(max_len,1+dfs(v));
	    }
	    return dp[u]=max_len;
	};
    int n=adj.size();
    int res=0;
    for (int i=0;i<n;i++) {
        res=max(res,dfs(i));
    }
    return res;
}
```

### SCC

```c++
//强联通分量 Strong Connected Conponent
struct SCC {
	int n;
	vector<vector<int>> adj;
	vector<int> dfn,low,bel,stk;
	int cur,cnt;
	SCC() {};
	
	void init(int n) {
		this->n=n;
		adj.assign(n,{});
		dfn.assign(n,-1);
		low.assign(n,-1);
		bel.assign(n,-1);
		stk.clear();
		cur=cnt=0;
	}
	
	SCC(int n) {init(n);}
	
	void add(int u,int v) {	
		adj[u].push_back(v);
	}
	
	void dfs(int x) {
		dfn[x]=low[x]=cur++;
		stk.push_back(x);
		for(auto y : adj[x]) {
			if (dfn[y] == -1) {
				dfs(y);
				low[x]=min(low[x],low[y]);
			}	
			else if (bel[y] == -1){
				low[x]=min(low[x],dfn[y]);
			}
		}
		
		if (dfn[x] == low[x]) {
			int y;
			do {
				y=stk.back();
				bel[y]=cnt;
				stk.pop_back();
			} while (y != x);
			cnt++;
		}
	}
	
	vector<int> work() {
		for(int i=0;i<n;i++) {
			if (dfn[i] == -1) dfs(i);
		}
		return bel;
	}
	
	vector<vector<int>> getDAG() {
		work();
		vector dag(cnt,vector<int>(0));
		for(int u=0;u<n;u++) {
			for(auto v : adj[u]) {
				if (bel[u] != bel[v]) dag[bel[u]].push_back(bel[v]);
			}
		}
		for(int i=0;i<cnt;i++) {
			ranges::sort(dag[i]);
			dag[i].erase(unique(dag[i].begin(),dag[i].end()),dag[i].end());
		}
		return dag;
	}
};
```

### VBCC

```c++
struct VBCC {
    int n;
    vector<vector<array<int,2>>> adj;
    vector<array<int,2>> edge;
    vector<int> dfn,low,bel;
    vector<int> stk;
    vector<int> vis;
    int cur,cnt;

    VBCC() {};

    void init(int n) {
        this->n=n;
        adj.assign(n,{});
        edge.clear();
        dfn.assign(n,-1);
        low.assign(n,-1);
        vis.clear();
        stk.clear();
        cur=cnt=0;
    }

    VBCC(int n) {
        init(n);
    }

    void add(int u,int v) {
        adj[u].push_back({v,(int)edge.size()});
        adj[v].push_back({u,(int)edge.size()});
        edge.push_back({u,v});
    }

    void dfs(int u) {
        dfn[u]=low[u]=cur++;
        for (auto [v,pos] : adj[u]) {
            if (vis[pos]) continue;
            vis[pos]=1;
            stk.push_back(pos);
            if (dfn[v] == -1) {
                dfs(v);
                low[u]=min(low[u],low[v]);
                if (low[v] >= dfn[u]) {
                    int y;
                    do {
                        y = stk.back();
                        bel[y] = cnt;
                        stk.pop_back();
                    } while (y != pos);
                    cnt++;
                }
            }
            else low[u]=min(low[u],dfn[v]);
        }
    }

    vector<int> work() {
        bel.assign(edge.size(),-1);
        vis.assign(edge.size(),0);
        for (int i=0;i<n;i++) {
            if (dfn[i] == -1) dfs(i);
        }
        return bel;
    }
    
    vector<set<int>> getEdge() {
    	work();
	    vector<set<int>> E(cnt);
	    for(int i=0;i<edge.size();i++) {
	    	if (bel[i] == -1) continue;
	        auto [u,v]=edge[i];
	        E[bel[i]].insert(i);
	    }
	    return E;
    }
};
```

### EBCC

```c++
set<pair<int, int>> E;
struct EBCC {
    int n;
    vector<vector<int>> adj;
    vector<int> stk;
    vector<int> dfn,low,bel;
    int cur,cnt;
    
    EBCC() {}
    EBCC(int n) {
        init(n);
    }
    
    void init(int n) {
        this->n=n;
        adj.assign(n,{});
        dfn.assign(n,-1);
        low.resize(n);
        bel.assign(n,-1);
        stk.clear();
        cur=cnt=0;
    }
    
    void add(int u,int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    void dfs(int x,int p) {
        dfn[x]=low[x]=cur++;
        stk.push_back(x);
        for (auto y : adj[x]) {
            if (y == p) continue;
            if (dfn[y] == -1) {
                E.emplace(x,y);
                dfs(y,x);
                low[x]=min(low[x],low[y]);
            } else if (bel[y] == -1 and dfn[y] < dfn[x]) {
                E.emplace(x,y);
                low[x]=min(low[x],dfn[y]);
            }
        }
        
        if (dfn[x] == low[x]) {
            int y;
            do {
                y=stk.back();
                bel[y]=cnt;
                stk.pop_back();
            } while (y != x);
            cnt++;
        }
    }
    
    vector<int> work() {
        dfs(0, -1);
        return bel;
    }
    
    struct Graph {
        int n;
        vector<pair<int, int>> edges;
        vector<int> siz;
        vector<int> cnte;
    };
    Graph compress() {
        Graph g;
        g.n = cnt;
        g.siz.resize(cnt);
        g.cnte.resize(cnt);
        for (int i = 0; i < n; i++) {
            g.siz[bel[i]]++;
            for (auto j : adj[i]) {
                if (bel[i] < bel[j]) g.edges.emplace_back(bel[i], bel[j]);
                else if (i < j) g.cnte[bel[i]]++;
            }
        }
        return g;
    }
};
```

### 割点

```c++
// 割点 (Articulation Point)
struct CutV {
	int n;
	vector<vector<int>> adj;
	vector<int> dfn,low;
	vector<bool> flag;
	int cur;
	
	CutV() {};
	
	void init(int n) {
		this->n=n;
		adj.assign(n,{});
		dfn.assign(n,-1);
		low.assign(n,-1);
		flag.assign(n,0);
		cur=0;
	}
	
	CutV(int n) {init(n);}
	
	void add(int u,int v) {
		adj[u].push_back(v);
		adj[v].push_back(u);
	}
	
	void dfs(int u,int fa=-1) {
		dfn[u]=low[u]=cur++;
		int cnt=0;
		for(auto v : adj[u]) {
			if (v == fa) continue;
			if (dfn[v] == -1) {
				cnt++;
				dfs(v,u);
				low[u]=min(low[u],low[v]);
				if (fa != -1 and low[v] >= dfn[u]) flag[u]=1;
			}
			else low[u]=min(low[u],dfn[v]);
		}
		if (fa == -1 and cnt > 1) flag[u]=1;
	}
	
	vector<bool> work() {
		cur=0;
		for(int i=0;i<n;i++) {
			if (dfn[i] == -1) dfs(i,-1);
		}
		return flag;
	}
};
```

### 割边

```c++
// 割边 (Bridge)
struct CutE {
	int n;
	vector<vector<int>> adj;
	vector<int> dfn, low;
	int cur;
	vector<pair<int, int>> edge;
	
	CutE() {};
	
	void init(int n) {
		this->n=n;
		adj.assign(n,{});
		dfn.assign(n,-1);
		low.assign(n,-1);
		edge.clear();
		cur=0;
	}
	
	CutE(int n) {init(n);}
	
	void add(int u,int v) {	
		adj[u].push_back(v);
		adj[v].push_back(u);
	}
	
	void dfs(int u, int parent = -1) {
		dfn[u]=low[u]=cur++;
		for(auto v : adj[u]) {
			if (v == parent) continue;
			if (dfn[v] == -1) {
				dfs(v, u);
				low[u]=min(low[u],low[v]);
				if (low[v] > dfn[u]) {
					if (u < v) edge.push_back({u, v});
					else edge.push_back({v, u});
				}
			}	
			else low[u]=min(low[u],dfn[v]);
		}
	}
	
	vector<pair<int, int>> work() {
		cur=0;
		edge.clear();
		for(int i=0;i<n;i++) {
			if (dfn[i] == -1) dfs(i, -1);
		}
		return edge;
	}
};
```

### 树上启发式合并

```c++
//1-based
vector<int> c(n+1);//每个节点的颜色
vector<int> ans(n+1),cnt(n+1),siz(n+1),fa(n+1),son(n+1);
int diff=0,flag=0;
function<void(int,int)> get_info=[&](int u,int f)
{
    fa[u]=f;
    siz[u]=1;
    for (auto v : adj[u]) {
        if (v == f) continue;
        get_info(v,u);
        siz[u]+=siz[v];
        if (siz[v] > siz[son[u]]) son[u]=v;
    }
};
get_info(1,0);

function<void(int,int,int)> count=[&](int u,int f,int val) {
    cnt[c[u]]+=val;
    if (cnt[c[u]] == 0) diff--;
    else if (cnt[c[u]] == 1) diff++;
    for (auto v : adj[u]) {
        if (v == f or v == flag) continue;
        count(v,u,val);
    }
};

function<void(int,int,bool)> dfs=[&](int u,int f,bool ok) {
    for (auto v : adj[u]) {
        if (v == f or v == son[u]) continue;
        dfs(v,u,0);
    }
    if (son[u]) dfs(son[u],u,1),flag=son[u];
    count(u,f,1);
    ans[u]=diff;
    flag=0;
    if (ok == 0) {
        count(u,f,-1);
        diff=0;
    }
};
dfs(1,0,0);
```

### (min,+)卷积矩阵快速幂

```c++
//Min-Plus求floyd最短路
const int inf=1e18;
vector<vector<int>> operator * (const vector<vector<int>>& A,const vector<vector<int>>& B) {
	const int n=A.size();
	vector C(n,vector<int>(n,inf));
    for (int i=0;i<n;i++) {
        for (int k=0;k<n;k++) {
        	if (A[i][k] == inf) continue;
            for (int j=0;j<n;j++) {
                C[i][j]=min(C[i][j],A[i][k]+B[k][j]);
            }
        }
    }
    return C;
}

vector<vector<int>> Pow(vector<vector<int>> A,int exp) {
	int n=A.size();
	vector res(n,vector<int>(n,inf));
	for(int i=0;i<n;i++) res[i][i]=0;
	while (exp) {
		if (exp&1) res=res*A;
		A=A*A;
		exp>>=1;
	}
	return res;
}
```

### 重链剖分

```c++
struct HLD
{
    int n, root;
    vector<int> top, son, siz, dep, dfn, pos, fa;
    vector<vector<int>> g;
    int cur;
    HLD(int n, int root) : n(n), root(root)
    {
        init();
    }
    void init()
    {
        g.assign(n + 1, {});
        top.assign(n + 1, 0);
        fa.assign(n + 1, 0);
        son.assign(n + 1, 0);
        pos.assign(n + 1, 0);
        dep.assign(n + 1, 0);
        dfn.assign(n + 1, 0);
        siz.assign(n + 1, 0);
        dep[0] = -1;
        cur = 1;
    }
    void add(int u, int v)
    {
        g[u].pb(v);
        g[v].pb(u);
    }
    void dfs1(int u, int f)
    {
        fa[u] = f, dep[u] = dep[f] + 1, siz[u] = 1;
        for (auto v : g[u])
        {
            if (v == f)
                continue;
            dfs1(v, u);
            siz[u] += siz[v];
            if (siz[v] > siz[son[u]])
                son[u] = v;
        }
    }
    void dfs2(int u, int ftop)
    {
        dfn[u] = cur, pos[cur] = u, top[u] = ftop;
        cur++;
        if (son[u])
            dfs2(son[u], ftop);
        for (auto v : g[u])
        {
            if (v == son[u] || v == fa[u])
                continue;
            dfs2(v, v);
        }
    }
    void work()
    {
        dfs1(root, 0);
        dfs2(root, root);
    }
    int lca(int u, int v)
    {
        while (top[u] != top[v])
        {
            if (dep[top[u]] > dep[top[v]])
                u = fa[top[u]];
            else
                v = fa[top[v]];
        }
        return dep[u] > dep[v] ? v : u;
    }
};
struct Info
{
    int sum;
    int size;
    Info() : sum(), size(0) {};
    Info(int value) : sum(value), size(1) {};
    Info operator+(const Info &other) const
    {
        Info res;
        res.sum = sum + other.sum;
        res.sum %= mod;
        if (res.sum < 0)
            res.sum += mod;
        res.size = size + other.size;
        return res;
    }
};
void solve()
{
    int n, m, r;
    cin >> n >> m >> r >> mod;
    HLD g(n, r);
    SegTree sum(n + 1);
    vector<int> a(n + 1);
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    for (int i = 1; i < n; i++)
    {
        int u, v;
        cin >> u >> v;
        g.add(u, v);
    }
    g.work();
    for (int i = 1; i <= n; i++)
    {
        sum.modify(g.dfn[i], a[i]);
    }
    for (int i = 1; i <= m; i++)
    {
        int op;
        cin >> op;
        if (op == 1)
        {
            int u, v, w;
            cin >> u >> v >> w;
            int l, r;
            while (g.top[u] != g.top[v])
            {
                if (g.dep[g.top[u]] > g.dep[g.top[v]])
                {
                    r = g.dfn[u], l = g.dfn[g.top[u]];
                    sum.rangeAdd(l, r + 1, w);
                    u = g.fa[g.top[u]];
                }
                else
                {
                    r = g.dfn[v], l = g.dfn[g.top[v]];
                    sum.rangeAdd(l, r + 1, w);
                    v = g.fa[g.top[v]];
                }
            }
            l = min(g.dfn[v], g.dfn[u]), r = max(g.dfn[v], g.dfn[u]);
            sum.rangeAdd(l, r + 1, w);
        }
        else if (op == 2)
        {
            int u, v;
            cin >> u >> v;
            int ans = 0;
            int l, r;
            while (g.top[u] != g.top[v])
            {
                if (g.dep[g.top[u]] > g.dep[g.top[v]])
                {
                    r = g.dfn[u], l = g.dfn[g.top[u]];
                    ans += sum.query(l, r + 1).sum;
                    ans %= mod;
                    u = g.fa[g.top[u]];
                }
                else
                {
                    r = g.dfn[v], l = g.dfn[g.top[v]];
                    ans += sum.query(l, r + 1).sum;
                    ans %= mod;
                    v = g.fa[g.top[v]];
                }
            }
            l = min(g.dfn[v], g.dfn[u]), r = max(g.dfn[v], g.dfn[u]);
            ans += sum.query(l, r + 1).sum;
            cout << ans % mod << '\n';
        }
        else if (op == 3)
        {
            int u, w;
            cin >> u >> w;
            int l = g.dfn[u], r = g.dfn[u] + g.siz[u] - 1;
            sum.rangeAdd(l, r + 1, w);
        }
        else
        {
            int u;
            cin >> u;
            int l = g.dfn[u], r = g.dfn[u] + g.siz[u] - 1;
            cout << sum.query(l, r + 1).sum % mod << '\n';
        }
    }
}
```

### bfs找环例题

```c++
//2025 ICPC 沈阳 F
//找无向图里的简单环，要求环是极小的

void print(int u,int v) {
	cout<<u+1<<" "<<v+1<<"\n";
}
void solve()
{
	int n,m,s,t;
	cin>>n>>m>>s>>t;
	s--,t--;
	
	vector<int> fa(n,-1);
	vector<array<int,2>> edge;
	vector adj(n,vector<array<int,2>>(0));
	vector<int> visp(n);
	vector<int> vise(m);
	vector<array<int,2>> ans(m);
	int pos=-1;
	for(int i=0;i<m;i++) {
		int u,v;
		cin>>u>>v;
		u--,v--;
		if (u == s and v == t or u == t and v == s) pos=i;
		edge.push_back({u,v});
		adj[u].push_back({v,i});
		adj[v].push_back({u,i});
	}
	
	if (pos == -1) {
		cout<<"Yes\n";
		for(auto [u,v] : edge) {
			if (u == s or u == t) print(v,u);
			else print(u,v);
		}
		return;
	}
	
	auto check=[&]() -> int {
		queue<int> q;
		q.push(s),q.push(t);
		visp[s]=visp[t]=1;
		fa[s]=fa[t]=pos;
		while (!q.empty()) {
			int u=q.front();
			q.pop();
			for(auto [v,i] : adj[u]) {
				if (i == fa[u]) continue;
				if (visp[v]) return i;
				q.push(v);
				visp[v]=1;
				fa[v]=i;
				ans[i]={v,u};
			}
		}
		return -1;
	};
	
	auto work=[&](int r,bool update) {
		while (1) {
			int p=fa[r];
			vise[p]=1;
			auto [u,v]=edge[p];
			visp[u]=visp[v]=2;
			if (u == r) {
				if (update) ans[p]={v,u};
				r=v;
			}
			else {
				if (update) ans[p]={u,v};
				r=u;
			}
			if (p == pos) break;
		}
	};
	
	int st=check();
	if (st == -1) {cout<<"No\n";return;}
	vise[st]=1;
	auto [l,r]=edge[st];
	ans[st]={r,l};
	work(r,1);
	work(l,0);
	
	queue<int> q;
	for(int i=0;i<n;i++) {
		if (visp[i] == 2) q.push(i);
	}
	
	while (!q.empty()) {
		int u=q.front();
		q.pop();
		for(auto [v,i] : adj[u]) {
			if (vise[i]) continue;
			vise[i]=1;
			ans[i]={v,u};
			q.push(v);
		}
	}
	
	cout<<"Yes\n";
	for(int i=0;i<m;i++) {
		print(ans[i][0],ans[i][1]);
	}
}
```



## 数学

gcd(a, bc) == gcd(a, b) * gcd(a/gcd(a,b), c)

整数分块结论：一个区间的左端点L，右端点是n/(n/L)。

### Floor Sqrt

```c++
int Sqrt(i64 n) {
    int x=sqrt(n);
    if (x*x > n) {
        x--;
    }
    return x;
}
```

### 埃氏筛

```c++
int n;
cin>>n;
vector<bool> isp(n+1,1);
isp[0]=0;
isp[1]=0;
for(int i=2;i<=n;i++) {
    if (isp[i] == 0) continue;
    for(int j=i;i*j<=n;j++) {
        isp[i*j]=0;
    }
}
```

### 欧拉筛

```C++
struct Sieve {
    vector<int> spf,primes;

    Sieve(int n=1e6) : spf(n+1) {
        for (int i=2;i<=n;i++) {
            if (!spf[i]) primes.push_back(spf[i]=i);
            for (int p : primes) {
                if (i*p > n) break;
                spf[i*p]=p;
                if (i%p == 0) break;
            }
        }
    }

    // [质因子,指数] O(logn)
	vector<pair<int,int>> fact(int v) {
	    vector<pair<int,int>> res;
	    for (int p : primes) {
	        if (p*p > v or v < spf.size()) break;
	        if (v%p == 0) {
	            int c=0;
	            while (v%p == 0) v/=p,c++;
	            res.emplace_back(p,c);
	        }
	    }
	    while (v > 1 and v < spf.size()) {
	        int p=spf[v];
	        int c=0;
	        while (v%p == 0) v/=p,c++;
	        res.emplace_back(p,c);
	    }
	    if (v > 1) res.emplace_back(v,1);
	    return res;
	}

	//所有因数,O(O(fact)+因数个数)
    vector<int> divs(int v) {
        vector<int> res={1};
        for (auto [p,c] : fact(v)) {
            int sz=res.size();
            int x=p;
            for (int i=0;i<c;i++,x*=p)
                for (int j=0;j<sz;j++) res.push_back(res[j]*x);
        }
        return res;
    }

	//可筛1e12
    bool isPrime(int v) {
        if (v < spf.size()) return v > 1 and spf[v] == v;
        for (int p : primes) {
            if (p*p > v) break;
            if (v%p == 0) return 0;
        }
        return v > 1;
    }
};

Sieve sieve;
```

### exgcd

```c++
int d,X,Y,PX,PY;//d为最大公因数; (X,Y)是一组特解
void exgcd(int a,int b)//a,b当前的两个过程数字,不用考虑入参大小
{
	if (b != 0) {
		exgcd(b,a%b);
		PX=X;//PX更新为下一次的x
		PY=Y;//PY更新为下一次的y
		X=PY;//求解的这次的x就是下次的y
		Y=PX-PY*(a/b);
	} else {
		d=a;
		X=1;
		Y=0;
	}
}

void solve()
{
	int a,b,c;
	cin>>a>>b>>c;
	if (c%(gcd(a,b)) != 0) {cout<<-1<<endl;return;}
	exgcd(a,b);
	X*=c/d;
	Y*=c/d;
	//先算minx
	int t=ceil((1.0-X)/(b/d));
	int minx=X+t*b/d;
	int maxy=Y-t*a/d;
	//再算maxx;
	t=ceil((1.0-Y)/(a/d));
	int maxx=X-t*b/d;
	int miny=Y+t*a/d;
	int num=(maxx-minx)/(b/d)+1;
	if (minx>0 and maxy>0) cout<<num<<" "<<minx<<" "<<miny<<" "<<maxx<<" "<<maxy<<endl;
	else cout<<minx<<" "<<miny<<endl;
}
```

### 进制转换

```c++
char s[40],t[40];
signed main(){
	int n,m;
	cin>>n>>s>>m;//原来的进制n,数字s,要转成的进制m
    to_chars(t,t+40,strtol(s,NULL,n),m);//将数字s先转成n进制的ll,再将ll的s转化为m进制并存入t中
    for(int i=0;i<40;i++) if (t[i] >= 'a' and t[i] <='z') t[i]-=32;
    cout<<t;
    return 0;
}
```

### 组合数学

```c++
//带模数
const int p=1e9+7;
const int N=1e6;
int jc[N+1];
int inv[N+1];

int Pow(int base,int exp) {
	int res=1;
	base%=p;
	for(;exp;exp>>=1) {
		if (exp&1) res*=base,res%=p;
		base*=base,base%=p;
	}
	return res;
}

int Inv(int num) {
	return Pow(num,p-2);
}

int C(int m,int n)
{
	if (m < n) return 0;
	return jc[m]*inv[m-n]%p*inv[n]%p;
}

int Lucas(int m,int n)
{
	if (m == 0) return 1;
	return C(m%p,n%p)*Lucas(m/p,n/p)%p;
}

	jc[0]=1;
	for(int i=1;i<=N;i++) jc[i]=jc[i-1]*i%p;
	
	//连续数字逆元的线性递推
	inv[1]=1;
	for(int i=2;i<=N;i++) inv[i]=p-inv[p%i]*(p/i)%p;

	//连续阶乘逆元的线性递推
	inv[N]=Pow(jc[N],p-2);
	for(int i=N-1;i>=0;i--) inv[i]=(i+1)*inv[i+1]%p;
```



## 博弈论

### NIM博弈

经典NIM：n堆里每次只能拿一堆的1-m个石子，sg定理可以解决。

K-NIM：n堆里每次可以拿1-k堆的1-m个石子，二进制处理每堆的数量，如果第i位中1的个数是cnt，cnt%(k+1) == 0时，输，否则赢。证明也很简单，目的是让n个数字每一位变成0，对于第i位，目的是来回若干次操作若能让其归零，当 k+1|cnt 时，先手做不到归零。

​		用sg定理就是，n堆石子的异或和%(k+1)，证明类似，就是每位异或等价于每一位的1的总和%2，%2%(k+1)等价于%(k+1)%2。

### 巴什博弈打表

```c++
//经典巴什博弈例题，每人只能拿2的若干次石子
//枚举我们所有取的可能，对面只要有一个必败态，通过mex我们就是必胜的
int mex(set<int> st) {
	for(int i=0;;i++) {
		if (st.find(i) == st.end()) return i;
	}
}

void solve()
{
	int n;
	while (cin>>n) {
		unordered_map<int,int> mp;
		auto sg=[&](auto self,int x) -> int {
			if (mp.count(x)) return mp[x];
			
			set<int> st;
			for(int i=1;i<=x;i<<=1) st.insert(self(self,x-i));
			return mp[x]=mex(st);
		};
		
		for(int i=0;i<100;i++) cout<<sg(sg,i)<<' ';
		// cout<<(sg(sg,n) == 0 ? "Cici\n" : "Kiki\n");
		// cout<<(n%3 == 0 ? "Cici\n" : "Kiki\n");
	}
}
```

### sg函数

```c++
//画线博弈
//类似于一堆石子不断分开
int mex(set<int> st) {
	for(int i=0;;i++) {
		if (st.find(i) == st.end()) return i;
	}
}

void solve()
{
	unordered_map<int,int> mp;
	mp[0]=0,mp[1]=0,mp[2]=1,mp[3]=1;
	auto sg=[&](auto self,int x) -> int {
		if (mp.count(x)) return mp[x];
		set<int> st;
		for(int i=0;i<=x-2;i++) {
			st.insert(self(self,i)^self(self,x-2-i));
		}
		
		return mp[x]=mex(st);
	};
	
	for(int i=0;i<=1000;i++) cout<<sg(sg,i)<<",";
}
```

### sg函数 二维

```c++
//题意是选择第2k和2k+1的石子，选择丢弃一堆，分另一堆
void solve()
{
	int n=100;
	vector dp(n,vector<int>(n,-1));
	auto sg=[&](this auto &&self,int x,int y) -> int {
		if (x == 1 and y == 1) return 0;
		if (dp[x][y] != -1) return dp[x][y];
		vector<int> app(max(x,y)+1);
		if (x > 1) {
			for(int i=x-1;i>0;i--) app[self(i,x-i)]=1;
		}
		if (y > 1) {
			for(int i=y-1;i>0;i--) app[self(i,y-i)]=1;
		}
		
		for(int i=0;i<=max(x,y);i++) {
			if (app[i] == 0) {
				dp[x][y]=i;
				return i;
			}
		}
	};
	for(int j=0;j<n;j++) cout<<j<<" ";
	cout<<"\n\n"; 
	for(int i=0;i<n;i++) {
		for(int j=0;j<n;j++) {
			dp[i][j]=sg(i,j);
			cout<<dp[i][j]<<" \n"[j == n-1];
		}
	}
}
```



## 动态规划

### 矩阵快速幂加速

```c++
const int inf=1e18;
vector<vector<int>> operator * (const vector<vector<int>>& A,const vector<vector<int>>& B) {
	const int n=A.size();
	vector C(n,vector<int>(n,inf));
    for (int i=0;i<n;i++) {
        for (int k=0;k<n;k++) {
        	if (A[i][k] == inf) continue;
            for (int j=0;j<n;j++) {
                C[i][j]=min(C[i][j],A[i][k]+B[k][j]);
            }
        }
    }
    return C;
}

vector<vector<int>> Pow(vector<vector<int>> E,vector<vector<int>> A,int exp) {
	int n=A.size();
	for(;exp;exp>>=1) {
		if (exp&1) E=E*A;
		A=A*A;
	}
	return E;
}
```

### 经典01背包

```c++
auto bag=[&]() -> int {
    vector<int> dp(T+1);
    for(int i=0;i<n;i++) {
        for(int j=T;j>=cost[i];j--) {
            dp[j]=max(dp[j],dp[j-cost[i]]+val[i]);
        }
    }
    return dp[T];
};



auto bag=[&]() -> int {
    vector dp(n+1,vector<int>(T+1));
    for(int i=1;i<=n;i++) {
        for(int j=0;j<=T;j++) {
            if (j-cost[i] < 0) dp[i][j]=dp[i-1][j];	
            else dp[i][j]=max(dp[i-1][j],dp[i-1][j-cost[i]]+val[i]);
        }
    }
    return dp[n][T];
};
```

### 完全背包

```c++
// 严格位置依赖
vector dp(n+1,vector<int>(m+1));

for(int i=1;i<=n;i++) {
    for(int j=0;j<=m;j++) {
        dp[i][j]=dp[i-1][j];
        if (j-cost[i] >= 0) dp[i][j]=max(dp[i][j],dp[i][j-cost[i]]+val[i]);
    }
}
cout<<dp[n][m];


// 空间压缩
vector<int> dp(m+1);

for(int i=1;i<=n;i++) {
    for(int j=cost[i];j<=m;j++) {
        dp[j]=max(dp[j],dp[j-cost[i]]+val[i]);
    }
}
cout<<dp[m];


// 可行方案数，滚动数组优化
vector<int> dp(m+1);
dp[0]=1;
for(int i=1;i<=n;i++) {
    for(int j=cost[i];j<=m;j++) {
        dp[j]+=dp[j-cost[i]];
    }
}
cout<<dp[m];
```

### 有依赖的背包

```c++
// Problem: P1064 [NOIP 2006 提高组] 金明的预算方案
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P1064
void solve()
{
	int n,m;
	cin>>n>>m;
	vector<int> cost(m+1),val(m+1),kind(m+1);
	for(int i=1;i<=m;i++) {
		cin>>cost[i]>>val[i]>>kind[i];
		val[i]*=cost[i];
	}
	
	vector<bool> king(m+1,0);
	vector adj(m+1,vector<int>(0));//存主件的附件的指针
	
	for(int i=1;i<=m;i++) {
		if (kind[i] == 0) king[i]=1;
		else adj[kind[i]].push_back(i);
	}
	
	
	vector dp(m+1,vector<int>(n+1));
	int p=0;//存上一个主件的指针
	for(int i=1;i<=m;i++) {
		if (!king[i]) continue;	
		for(int j=n;j>=0;j--) {
			dp[i][j]=dp[p][j];
			//要i
			if (j-cost[i] >= 0) dp[i][j]=max(dp[i][j],dp[p][j-cost[i]]+val[i]);
			else continue;
			int k1,k2;
			//如果有附1
			if (adj[i].size() >= 1) {
				k1=adj[i][0];
				if (j-cost[k1]-cost[i] >= 0) dp[i][j]=max(dp[i][j], dp[p][j-cost[k1]-cost[i]]+val[k1]+val[i]);
			}
			//如果有附2
			if (adj[i].size() == 2) {
				k2=adj[i][1];
				if (j-cost[k2]-cost[i] >= 0) dp[i][j]=max(dp[i][j], dp[p][j-cost[k2]-cost[i]]+val[k2]+val[i]);
				if (j-cost[k1]-cost[k2]-cost[i] >= 0) dp[i][j]=max(dp[i][j], dp[p][j-cost[k1]-cost[k2]-cost[i]]+val[k1]+val[k2]+val[i]);
			}
		}
		p=i;
	}
	
	
	cout<<dp[p][n];
}
```

### 分组背包

```c++
// Problem: P1757 通天之分组背包
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P1757
void solve()
{
	int m,n;
	cin>>m>>n;
	vector adj(101,vector<array<int,2>>(0));//100个组
	for(int i=1;i<=n;i++) {
		int cost,val,kind;
		cin>>cost>>val>>kind;
		adj[kind].push_back( {cost,val} );
	}
	
	vector dp(101,vector<int>(m+1));
	int p=0;
	for(int i=1;i<=100;i++) {
		if (adj[i].size() == 0) continue;
		for(int j=0;j<=m;j++) {
			dp[i][j]=dp[p][j];
			for(int k=0;k<adj[i].size();k++) {
				int cost=adj[i][k][0];
				int val=adj[i][k][1];
				if (j-cost >= 0) dp[i][j]=max(dp[i][j],dp[p][j-cost]+val);
			}
		}
		p=i;
	}
	cout<<dp[p][m];
}
```

### 多重背包 二进制分组优化

```
// Problem: P1776 宝物筛选
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P1776

void solve()
{
	int n,m;
	cin>>n>>m;
	vector<array<int,2>> gra;
	for(int i=1;i<=n;i++) {
		int val,cost,num;
		cin>>val>>cost>>num;
		for(int i=0;num-(1<<i) >= 0;i++) {
			int k=(1<<i);
			gra.push_back({cost*k,val*k});
			num-=k;
		}
		if (num != 0) gra.push_back({cost*num,val*num});
	}
	
	n=gra.size();
	vector<int> dp(m+1);
	for(int i=0;i<n;i++) {
		for(int j=m;j>=gra[i][0];j--) {
			dp[j]=max(dp[j],dp[j-gra[i][0]]+gra[i][1]);
		}
	}
	cout<<dp[m];
}
```



## 字符串

### KMP

```c++
vector<int> Next(string s) {
	int m=s.size();
	vector<int> next(m+1);
	next[0]=-1;
	next[1]=0;
	int i=2,cur=0;
	while (i < m+1) {
		if (s[i-1] == s[cur]) next[i++]=++cur;
		else if (cur > 0) cur=next[cur];
		else next[i++]=0;
	}
	return next;
}

int KMP(string s1,string s2) {
	int n=s1.size();
	int m=s2.size();
	auto next=Next(s2);
	int x=0,y=0;
	while (x < n and y < m) {
		if (s1[x] == s2[y]) {
			x++;
			y++;
		}
		else if (y == 0) x++;
		else y=next[y];
	}
	
	return y;
}
```

### 01Trie

```c++
constexpr int N=1e5*31;
int tot;
int trie[N][2];
int cnt[N];

int newNode() {
	int x=++tot;
	trie[x][0]=trie[x][1]=0;
	cnt[x]=0;
	return x;
}

void init() {
	tot=0;
	newNode();
}

void add(int x,int t) {
	int o=1;
	for(int i=30;i>=0;i--) {
		int &p=trie[o][x>>i&1];
		if (p == 0) p=newNode();
		o=p;
		cnt[o]+=t;
	}
}

int query(int x) {
	int o=1;
	int ans=0;
	for(int i=30;i>=0;i--) {
		int d=x>>i&1;
		if (cnt[trie[o][d^1]]) {
			ans|=1<<i;
			d^=1;
		}
		o=trie[o][d];
	}
	return ans;
}
```

### Trie

```c++
const int N=1e5;
int tree[N][26];
int pass[N];
int ed[N];
int len=1;

void insert(const string& s) {
	int cur=0;
	pass[cur]++;
	for(char c : s) {
		if (tree[cur][c-'a'] == 0) tree[cur][c-'a']=len++;
		cur=tree[cur][c-'a'];
		pass[cur]++;
	}
	ed[cur]++;
}

int query(const string& s) {
	int cur=0;
	for(char c : s) {
		if (tree[cur][c-'a'] == 0) return 0;
		cur=tree[cur][c-'a'];
	}
	return ed[cur];
}

int querypre(const string& s) {
	int cur=0;
	for(char c : s) {
		if (tree[cur][c-'a'] == 0) return 0;
		cur=tree[cur][c-'a'];
	}
	return pass[cur];
}

void erase(const string& s) {
	if (query(s) == 0) return;
	int cur=0;
	pass[cur]--;
	for(char c : s) {
		if (--pass[tree[cur][c-'a']] == 0) {
			tree[cur][c-'a']=0;
			return;
		}
		cur=tree[cur][c-'a'];
	}
	ed[cur]--;
}
```

### Trie哈希实现

```c++
const int N=1e5;
unordered_map<char,int> tree[N];
int pass[N];
int ed[N];
int len=1;

void insert(const string& s) {
	int cur=0;
	pass[cur]++;
	for(char c : s) {
		if (tree[cur].find(c) == tree[cur].end()) tree[cur][c]=len++;
		cur=tree[cur][c];
		pass[cur]++;
	}
	ed[cur]++;
}

int query(const string& s) {
	int cur=0;
	for(char c : s) {
		if (tree[cur].find(c) == tree[cur].end()) return 0;
		cur=tree[cur][c];
	}
	return ed[cur];
}

int querypre(const string& s) {
	int cur=0;
	for(char c : s) {
		if (tree[cur].find(c) == tree[cur].end()) return 0;
		cur=tree[cur][c];
	}
	return pass[cur];
}

void erase(const string& s) {
	if (query(s) == 0) return;
	int cur=0;
	pass[cur]--;
	for(char c : s) {
		if (--pass[tree[cur][c]] == 0) {
			tree[cur].erase(c);
			return;
		}
		cur=tree[cur][c];
	}
	ed[cur]--;
}
```



## 数据结构

### DSU

```c++
struct DSU {
	vector<int> f,siz;
	
	DSU() {}
	DSU(int n) {init(n);}
	
	void init(int n) {
		f.resize(n);
		iota(f.begin(),f.end(),0);
		siz.assign(n,1);
	}
	
	int find(int x) {
		while (x != f[x]) {
			x = f[x] = f[f[x]];
		}
		return x;
	}
	
	bool merge(int x,int y) {
		x=find(x);
		y=find(y);
		if (x == y) return 0;
		siz[x] += siz[y];
		f[y]=x;
		return 1;
	}
	
	int elesize(int x) {
		return siz[find(x)];
	}
	
	//返回根的数量
	int count() {
		unordered_set<int> roots;
		for(int i=0;i<f.size();i++) roots.insert(find(i));
		return roots.size();
	}
};
```

### 线段树 无懒标记

```c++
const int inf=1e18;
struct Info {
	int sum,Max,Min,Gcd,Xor;
	Info() : sum(0),Max(-inf),Min(inf),Gcd(0),Xor(0) {};
    Info(int val) : sum(val),Max(val),Min(val),Gcd(val),Xor(val) {};
    Info operator+(const Info &other) const {
    	Info res;
    	res.sum=sum+other.sum;
    	res.Min=min(Min,other.Min);
    	res.Max=max(Max,other.Max);
    	res.Gcd=gcd(Gcd,other.Gcd);
    	res.Xor=(Xor^other.Xor);
    	return res;
    }
};

struct SegTree {
	int n;
	vector<Info> info;
	SegTree(int n_) {
		n=n_;
		info.resize(n*4);
	}
	
	void Set(int v,int l,int r,int p,int val) {
		if (l == r) {info[v]=Info(val);return;}
		int m=l+r>>1;
		if (p <= m) Set(2*v,l,m,p,val);
		else Set(2*v+1,m+1,r,p,val);
		info[v]=info[v*2]+info[v*2+1];
	}
	
	Info query(int v,int l,int r,int ql,int qr) {
		if (ql > r or qr < l) return Info();
		if (ql <= l and r <= qr) return info[v];
		int m=l+r>>1;
		return query(2*v,l,m,ql,qr)+query(2*v+1,m+1,r,ql,qr);
	}
};
```

### 线段树 懒标记

```c++
const int inf=1e18;
struct Info {
	int sum,Max,Min;
	Info() : sum(0),Max(-inf),Min(inf) {};
    Info(int val) : sum(val),Max(val),Min(val) {};
    Info operator+(const Info &other) const {
    	Info res;
    	res.sum=sum+other.sum;
    	res.Min=min(Min,other.Min);
    	res.Max=max(Max,other.Max);
    	return res;
    }
};

struct SegTree {
	int n;
	vector<Info> info;
    vector<int> lazy_add,lazy_set;
    const int no_set = 1e18 + 7; 

	SegTree(int n_) {
		n=n_;
		info.resize(n*4);
        lazy_add.resize(n*4, 0);
        lazy_set.resize(n*4, no_set);
	}
	
    void apply_set(int v, int l, int r, int val) {
        info[v].sum = (r - l + 1) * val;
        info[v].Min = val;
        info[v].Max = val;
        lazy_set[v] = val;
        lazy_add[v] = 0;
    }

    void apply_add(int v, int l, int r, int val) {
        info[v].sum += (r - l + 1) * val;
        info[v].Min += val;
        info[v].Max += val;
        if (lazy_set[v] != no_set) {
            lazy_set[v] += val;
        } else {
            lazy_add[v] += val;
        }
    }

    void pushdown(int v, int l, int r) {
        int m = l + r >> 1;
        if (lazy_set[v] != no_set) {
            apply_set(v * 2, l, m, lazy_set[v]);
            apply_set(v * 2 + 1, m + 1, r, lazy_set[v]);
            lazy_set[v] = no_set;
        }
        if (lazy_add[v] != 0) {
            apply_add(v * 2, l, m, lazy_add[v]);
            apply_add(v * 2 + 1, m + 1, r, lazy_add[v]);
            lazy_add[v] = 0;
        }
    }
	
    void Set(int v, int l, int r, int ql, int qr, int val) {
        if (ql > r or qr < l) return;
        if (ql <= l and r <= qr) {
            apply_set(v, l, r, val);
            return;
        }
        pushdown(v, l, r);
        int m = l + r >> 1;
        Set(v * 2, l, m, ql, qr, val);
        Set(v * 2 + 1, m + 1, r, ql, qr, val);
        info[v] = info[v * 2] + info[v * 2 + 1];
    }

    void Add(int v, int l, int r, int ql, int qr, int val) {
        if (ql > r or qr < l) return;
        if (ql <= l and r <= qr) {
            apply_add(v, l, r, val);
            return;
        }
        pushdown(v, l, r);
        int m = l + r >> 1;
        Add(v * 2, l, m, ql, qr, val);
        Add(v * 2 + 1, m + 1, r, ql, qr, val);
        info[v] = info[v * 2] + info[v * 2 + 1];
    }

	Info query(int v,int l,int r,int ql,int qr) {
		if (ql > r or qr < l) return Info();
		if (ql <= l and r <= qr) return info[v];
        pushdown(v, l, r);
		int m=l+r>>1;
		return query(2*v,l,m,ql,qr)+query(2*v+1,m+1,r,ql,qr);
	}
};
```

### ST表 区间极值

```c++
//1-based
template<typename T, bool isMin>
struct SparseTable{
    int n, m;
    vector<vector<T>> f;
 
    SparseTable() {}
    SparseTable(int n) : n(n), m(__lg(n)), f(m + 1, vector<T>(n + 1)) {}
    SparseTable(const vector<T> &init) : SparseTable((int)init.size()){
        for(int i = 1; i <= n; i++){
            f[0][i] = init[i - 1];
        }
        for(int j = 1; j <= m; j++){
            for(int i = 1; i + (1 << j) - 1 <= n; i++){
                if (isMin) f[j][i] = min(f[j - 1][i], f[j - 1][i + (1 << (j - 1))]);
                else f[j][i] = max(f[j - 1][i], f[j - 1][i + (1 << (j - 1))]);
            }       
        }
    }
 
    T query(int l, int r){
        if (l > r){
            if (isMin) return numeric_limits<T>::max() / 10;
            return numeric_limits<T>::min() / 10;
        }
        int len = __lg(r - l + 1);
        if (isMin) return min(f[len][l], f[len][r - (1 << len) + 1]);
        return max(f[len][l], f[len][r - (1 << len) + 1]);        
    }
};
```

### ST表 区间gcd

```c++
//1-based
struct ST {
    #define lg2(n) (63 - __builtin_clzll((long long)(n)))
    int n, B;
    vector<vector<int>> st;
    ST (int n, vector<int> &a): n(n) {
        B = lg2(n) + 2;
        st.assign(B, vector<int>(n + 5, 0));
        for (int i = 1; i <= n; i++) st[0][i] = a[i];
 
        for (int j = 1; j < B; j++) {
            for (int i = 1; i + (1 << j) - 1 <= n; i++) {
                st[j][i] = gcd(st[j - 1][i], st[j - 1][i + (1 << (j - 1))]);
            }
        }
    }
 
    int query(int l, int r) {
        int k = lg2(r - l + 1);
        return gcd(st[k][l], st[k][r - (1 << k) + 1]);
    }
};
```



## 计算几何

### 平面几何基础

```c++
//这是平面几何基础内容，包括：
//法向量，极角，点积，叉积，模长，向量单位化，计算夹角，旋转向量
//两直线交点，两直线是否相交
//点到直线距离，点到线段最短距离，点到直线投影坐标，点是否在线段上
//计算三点构成的平行四边形面积，计算多边形面积，点与多边形关系

const double eps = 1e-9;
const double PI = acos(-1.0);

int sign(double x) {
    if (fabs(x) < eps) return 0;
    return x < 0 ? -1 : 1;
}

int cmp(double x, double y) {
    if (fabs(x - y) < eps) return 0;
    return x < y ? -1 : 1;
}

struct Point {
    double x, y;
    Point(double x = 0, double y = 0) : x(x), y(y) {}
    
    Point operator+(const Point& b) const { return Point(x + b.x, y + b.y); }
    Point operator-(const Point& b) const { return Point(x - b.x, y - b.y); }
    Point operator*(double k) const { return Point(x * k, y * k); }
    Point operator/(double k) const { return Point(x / k, y / k); }
    
    bool operator==(const Point& b) const { 
        return cmp(x, b.x) == 0 && cmp(y, b.y) == 0; 
    }
    
    bool operator<(const Point& b) const {
        int c = cmp(x, b.x);
        if (c != 0) return c == -1; 
        return cmp(y, b.y) == -1;   
    }
};
typedef Point Vector;

// ========================================================================

double dot(Vector a, Vector b) {
    return a.x * b.x + a.y * b.y;
}

double cross(Vector a, Vector b) {
    return a.x * b.y - b.x * a.y;
}

// 法向量
Vector normal(Vector a) { 
    return Vector(-a.y, a.x);
}

// 求向量的极角
double p_angle(Vector a) {
    return atan2(a.y, a.x);
}

// 极角排序
bool p_cmp(const Vector& a, const Vector& b) {
    int ha = (a.y > 0 or a.y == 0 and a.x > 0);
    int hb = (b.y > 0 or b.y == 0 and b.x > 0);
    if (ha != hb) return ha < hb;
    int c = cross(a, b);
    return c > 0;
}

// 获取向量的模长
double get_length(Vector a) {
    return hypot(a.x, a.y); 
}

// 将向量单位化
Vector unit(Vector a) {
    double l = get_length(a);
    if (sign(l) == 0) return a; // 防止除以 0 的情况
    return a / l;
}

// 计算两个非零向量的夹角
// 返回值：弧度制，范围 [0, PI]
double get_angle_robust(Vector a, Vector b) {
    return fabs(atan2(cross(a, b), dot(a, b))); 
}

// 向量 a 逆时针旋转 angle 角度 (弧度制)
Vector rotate(Vector a, double angle) {
    double c = cos(angle), s = sin(angle);
    return Vector(a.x * c - a.y * s, a.x * s + a.y * c);
}

// 计算点 a, b, c 构成的平行四边形有向面积 (以 a 为顶点)
double area(Point a, Point b, Point c) {
    return cross(b - a, c - a);
}

// 1. 判断两直线相交并求交点
// 直线表示形式：参数方程 P = p + v*t 和 Q = q + w*t
// 注意：需保证两直线不平行，即 cross(v, w) != 0
Point get_line_intersection(Point p, Vector v, Point q, Vector w) {
    assert(sign(cross(v, w)) != 0); // 确保直线不平行或共线
    Vector u = p - q;
    double t = cross(w, u) / cross(v, w);
    return p + v * t;
}

// 2. 求点 p 到直线 ab 的垂直距离
double distance_to_line(Point p, Point a, Point b) {
    Vector v1 = b - a; // 直线的方向向量
    Vector v2 = p - a; // a 到 p 的向量
    return fabs(cross(v1, v2) / get_length(v1)); // 面积除以底等于高
}

// 3. 求点 p 到线段 ab 的最短距离
double distance_to_segment(Point p, Point a, Point b) {
    if (a == b) return get_length(p - a); // 线段退化为点
    
    Vector v1 = b - a, v2 = p - a, v3 = p - b;
    // 判断 p 在线段所在直线的投影位置
    if (sign(dot(v1, v2)) < 0) return get_length(v2);   // 投影在端点 a 外侧
    if (sign(dot(v1, v3)) > 0) return get_length(v3);   // 投影在端点 b 外侧
    return distance_to_line(p, a, b);                   // 投影在线段 ab 内部
}

// 4. 求点 p 在直线 ab 上的投影点坐标
Point get_line_projection(Point p, Point a, Point b) {
    Vector v = b - a;
    // 利用点积求出投影长度的比例
    return a + v * (dot(v, p - a) / dot(v, v));
}

// 5. 判断点 p 是否在线段 ab 上
// 注意：该函数假设已知 p、a、b 三点共线，或者在调用前使用了叉积验证共线。
// 判断依据：p 和 a、b 构成的叉积为0（共线），且点积 <= 0（说明 p 在 a 和 b 中间或端点上）。
bool on_segment(Point p, Point a, Point b) {
    return sign(cross(p - a, p - b)) == 0 && sign(dot(p - a, p - b)) <= 0;
}

// 6. 判断两线段 a1a2 和 b1b2 是否相交（严格相交或端点相交）
bool segment_intersection(Point a1, Point a2, Point b1, Point b2) {
    // 步骤一：快速排斥实验 (Bounding Box 检查)
    // 排除两线段外接矩形完全不相交的情况
    if (min(a1.x, a2.x) > max(b1.x, b2.x) || max(a1.x, a2.x) < min(b1.x, b2.x) ||
        min(a1.y, a2.y) > max(b1.y, b2.y) || max(a1.y, a2.y) < min(b1.y, b2.y)) {
        return false;
    }
    
    // 步骤二：跨立实验 (利用叉积判断线段是否在彼此的两侧)
    double c1 = cross(a2 - a1, b1 - a1), c2 = cross(a2 - a1, b2 - a1);
    double c3 = cross(b2 - b1, a1 - b1), c4 = cross(b2 - b1, a2 - b1);
    return sign(c1) * sign(c2) <= 0 && sign(c3) * sign(c4) <= 0;
}

// 求多边形的面积
// 参数：多边形顶点的 vector，需按顺时针或逆时针顺序给出
double polygon_area(const vector<Point>& p) {
    double res = 0;
    int n = p.size();
    for (int i = 0; i < n; i++) {
        res += cross(p[i], p[(i + 1) % n]); // 累加三角形的有向面积
    }
    return fabs(res / 2.0);
}

// 判断点 p 与多边形 poly 的位置关系 (基于射线法/环绕数法)
// 返回值：2 表示点在多边形边界上，1 表示在多边形内部，0 表示在外部
int is_point_in_polygon(Point p, const vector<Point>& poly) {
    int n = poly.size();
    int wn = 0; // Winding Number 环绕数
    for (int i = 0; i < n; i++) {
        Point a = poly[i], b = poly[(i + 1) % n];
        
        // 检查是否在当前边的边界上
        if (on_segment(p, a, b)) return 2; 
        
        // 判断射线向右穿过边的次数
        int k = sign(cross(b - a, p - a));
        int d1 = sign(a.y - p.y);
        int d2 = sign(b.y - p.y);
        
        if (k > 0 && d1 <= 0 && d2 > 0) wn++;      // 逆时针方向穿过射线向上
        if (k < 0 && d2 <= 0 && d1 > 0) wn--;      // 顺时针方向穿过射线向下
    }
    return wn != 0 ? 1 : 0;
}
```

### 静态凸包Andrew

```c++
// 若用于斜率优化，a 取 {y轴截距, 斜率} 存入 Point 的 {x, y}
vector<Point> andrew_envelope(vector<Point>& a) {
    sort(a.begin(), a.end());
    vector<Point> l, h;
    for(const auto& p : a) {
        // sign <= 0 表示 p 在前进方向的右侧或共线，维护下凸壳（左转）
        while (l.size() > 1 && sign(area(l[l.size() - 2], l.back(), p)) <= 0) {
            l.pop_back();
        }
        // sign >= 0 表示 p 在前进方向的左侧或共线，维护上凸壳（右转）
        while (h.size() > 1 && sign(area(h[h.size() - 2], h.back(), p)) >= 0) {
            h.pop_back();
        }
        l.push_back(p);
        h.push_back(p);
    }
    
    // reverse(h.begin(), h.end());
    // h.insert(h.end(), l.begin() + 1, l.end() - 1); //完整凸包
    return h;
}
```

